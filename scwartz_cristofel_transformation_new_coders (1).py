# -*- coding: utf-8 -*-
"""scwartz-cristofel-transformation-new-coders.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lRBdbOA3go-qfbC7xxhwzOk9f29t2Wr-
"""

import numpy as np
from scipy.integrate import quad
import csv

# Parameters
alpha1 = 0.5
alpha2 = 0.5

# Constants (example values)
Ar, Ai = 0, 0
Cr, Ci = 1, 0

# Small epsilon to avoid zero raised to negative powers
eps = 1e-12

# Piecewise arg(s) on real axis
def arg_s(s):
    return np.pi if s < 0 else 0

def arg_s1(s):
    return np.pi if s < 1 else 0

# Theta function
def theta_s(s):
    return (alpha1 - 1) * arg_s(s) + (alpha2 - 1) * arg_s1(s)

# Real part of integrand
def real_integrand(s):
    abs_s = max(abs(s), eps)
    abs_s1 = max(abs(s - 1), eps)
    angle = theta_s(s)
    return (abs_s**(alpha1 - 1)) * (abs_s1**(alpha2 - 1)) * np.cos(angle)

# Imaginary part of integrand
def imag_integrand(s):
    abs_s = max(abs(s), eps)
    abs_s1 = max(abs(s - 1), eps)
    angle = theta_s(s)
    return (abs_s**(alpha1 - 1)) * (abs_s1**(alpha2 - 1)) * np.sin(angle)

# Numeric integral of real part from 0 to t
def real_integral(t):
    val, err = quad(real_integrand, 0, t)
    return val

# Numeric integral of imaginary part from 0 to t
def imag_integral(t):
    val, err = quad(imag_integrand, 0, t)
    return val

# Parametric functions x(t), y(t)
def x_num(t):
    return Ar + Cr * real_integral(t) - Ci * imag_integral(t)

def y_num(t):
    return Ai + Ci * real_integral(t) + Cr * imag_integral(t)

# Range and step
t_start = 0
t_end = 10
t_step = 0.001

t_values = np.arange(t_start, t_end + t_step, t_step)

# Open CSV file to write
with open('sc_parametric_coordinates.csv', 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(['t', 'x', 'y'])  # header

    for t in t_values:
        x = x_num(t)
        y = y_num(t)
        writer.writerow([t, x, y])

print("CSV file 'sc_parametric_coordinates.csv' created with x,y coordinates.")

import numpy as np
from scipy.integrate import quad
import csv

# Parameters
alpha1 = 0.5
alpha2 = 0.5

# Constants (example values)
Ar, Ai = 0, 0
Cr, Ci = 1, 0

# Small epsilon to avoid zero raised to negative powers
eps = 1e-12

# Piecewise arg(s) on real axis
def arg_s(s):
    return np.pi if s < 0 else 0

def arg_s1(s):
    return np.pi if s < 1 else 0

# Theta function
def theta_s(s):
    return (alpha1 - 1) * arg_s(s) + (alpha2 - 1) * arg_s1(s)

# Real part of integrand
def real_integrand(s):
    abs_s = max(abs(s), eps)
    abs_s1 = max(abs(s - 1), eps)
    angle = theta_s(s)
    return (abs_s**(alpha1 - 1)) * (abs_s1**(alpha2 - 1)) * np.cos(angle)

# Imaginary part of integrand
def imag_integrand(s):
    abs_s = max(abs(s), eps)
    abs_s1 = max(abs(s - 1), eps)
    angle = theta_s(s)
    return (abs_s**(alpha1 - 1)) * (abs_s1**(alpha2 - 1)) * np.sin(angle)

# Numeric integral of real part from 0 to t
def real_integral(t):
    val, err = quad(real_integrand, 0, t)
    return val

# Numeric integral of imaginary part from 0 to t
def imag_integral(t):
    val, err = quad(imag_integrand, 0, t)
    return val

# Parametric functions x(t), y(t) with upper integration limit as argument
def x_num(t, upper_limit):
    return Ar + Cr * real_integral(upper_limit) - Ci * imag_integral(upper_limit)

def y_num(t, upper_limit):
    return Ai + Ci * real_integral(upper_limit) + Cr * imag_integral(upper_limit)

# Range and step for base t
t_start = 0
t_end = 10
t_step = 0.001

t_values = np.arange(t_start, t_end + t_step, t_step)

# Number of upstairs steps (levels)
levels = 5  # 0 to 4 inclusive = 5 levels
delta = 0.2  # offset for integration upper limit per level

# Open CSV file to write all curves
with open('sc_parametric_coordinates_levels.csv', 'w', newline='') as csvfile:
    writer = csv.writer(csvfile)
    # Header with level info
    writer.writerow(['level', 't', 'x', 'y'])

    for level in range(levels):
        for t in t_values:
            upper_limit = t + level * delta
            # Keep upper_limit within some bounds if desired, else it may increase too much
            if upper_limit > t_end + levels * delta:
                upper_limit = t_end + levels * delta
            x = x_num(t, upper_limit)
            y = y_num(t, upper_limit)
            writer.writerow([level, t, x, y])

print("CSV file 'sc_parametric_coordinates_levels.csv' created with multiple curve levels.")

import numpy as np
from scipy.integrate import quad
import csv

# Parameters
alpha1 = 0.5
alpha2 = 0.5

# Constants (example values)
Ar, Ai = 0, 0
Cr, Ci = 1, 0

# Small epsilon to avoid zero raised to negative powers
eps = 1e-12

# Piecewise arg(s) on real axis
def arg_s(s):
    return np.pi if s < 0 else 0

def arg_s1(s):
    return np.pi if s < 1 else 0

# Theta function
def theta_s(s):
    return (alpha1 - 1) * arg_s(s) + (alpha2 - 1) * arg_s1(s)

# Real part of integrand
def real_integrand(s):
    abs_s = max(abs(s), eps)
    abs_s1 = max(abs(s - 1), eps)
    angle = theta_s(s)
    return (abs_s**(alpha1 - 1)) * (abs_s1**(alpha2 - 1)) * np.cos(angle)

# Imaginary part of integrand
def imag_integrand(s):
    abs_s = max(abs(s), eps)
    abs_s1 = max(abs(s - 1), eps)
    angle = theta_s(s)
    return (abs_s**(alpha1 - 1)) * (abs_s1**(alpha2 - 1)) * np.sin(angle)

# Numeric integral of real part from 0 to t
def real_integral(t):
    val, err = quad(real_integrand, 0, t)
    return val

# Numeric integral of imaginary part from 0 to t
def imag_integral(t):
    val, err = quad(imag_integrand, 0, t)
    return val

# Parametric functions x(t), y(t) with upper integration limit as argument
def x_num(t, upper_limit):
    return Ar + Cr * real_integral(upper_limit) - Ci * imag_integral(upper_limit)

def y_num(t, upper_limit):
    return Ai + Ci * real_integral(upper_limit) + Cr * imag_integral(upper_limit)

# Range and step for base t
t_start = 0
t_end = 10
t_step = 0.001

t_values = np.arange(t_start, t_end + t_step, t_step)

# Number of upstairs steps (levels)
levels = 5  # levels 0 to 4
delta = 0.2  # offset per level

for level in range(levels):
    filename = f'sc_parametric_coordinates_level_{level}.csv'
    with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['t', 'x', 'y'])  # header
        for t in t_values:
            upper_limit = t + level * delta
            # Clamp upper_limit to max range to avoid too large integration limit
            if upper_limit > t_end + levels * delta:
                upper_limit = t_end + levels * delta
            x = x_num(t, upper_limit)
            y = y_num(t, upper_limit)
            writer.writerow([t, x, y])
    print(f"CSV file '{filename}' created.")

print("All level CSV files generated successfully.")

https://math.stackexchange.com/questions/407839/schwarz-christoffel-transformation-point-at-infinity

import numpy as np
from scipy.integrate import quad
import csv

# Parameters
alpha1 = 0.5
alpha2 = 0.5

# Constants (example values)
Ar, Ai = 0, 0
Cr, Ci = 1, 0

# Small epsilon to avoid zero raised to negative powers
eps = 1e-12

# Piecewise arg(s) on real axis
def arg_s(s):
    return np.pi if s < 0 else 0

def arg_s1(s):
    return np.pi if s < 1 else 0

# Theta function
def theta_s(s):
    return (alpha1 - 1) * arg_s(s) + (alpha2 - 1) * arg_s1(s)

# Real part of integrand
def real_integrand(s):
    abs_s = max(abs(s), eps)
    abs_s1 = max(abs(s - 1), eps)
    angle = theta_s(s)
    return (abs_s**(alpha1 - 1)) * (abs_s1**(alpha2 - 1)) * np.cos(angle)

# Imaginary part of integrand
def imag_integrand(s):
    abs_s = max(abs(s), eps)
    abs_s1 = max(abs(s - 1), eps)
    angle = theta_s(s)
    return (abs_s**(alpha1 - 1)) * (abs_s1**(alpha2 - 1)) * np.sin(angle)

# Numeric integral of real part from 0 to t
def real_integral(t):
    val, err = quad(real_integrand, 0, t)
    return val

# Numeric integral of imaginary part from 0 to t
def imag_integral(t):
    val, err = quad(imag_integrand, 0, t)
    return val

# Parametric functions x(t), y(t) with upper integration limit as argument
def x_num(t, upper_limit):
    return Ar + Cr * real_integral(upper_limit) - Ci * imag_integral(upper_limit)

def y_num(t, upper_limit):
    return Ai + Ci * real_integral(upper_limit) + Cr * imag_integral(upper_limit)

# Range and step for base t
t_start = 0
t_end = 10
t_step = 0.001

t_values = np.arange(t_start, t_end + t_step, t_step)

# Levels for which you want to create CSV files
levels = [1, 2, 3]
delta = 0.2  # offset per level

for level in levels:
    x_filename = f'sc_parametric_coordinates_level_{level}_x.csv'
    y_filename = f'sc_parametric_coordinates_level_{level}_y.csv'

    with open(x_filename, 'w', newline='') as x_csvfile, open(y_filename, 'w', newline='') as y_csvfile:
        x_writer = csv.writer(x_csvfile)
        y_writer = csv.writer(y_csvfile)

        # Write headers
        x_writer.writerow(['t', 'x'])
        y_writer.writerow(['t', 'y'])

        for t in t_values:
            upper_limit = t + level * delta
            # Optional: clamp upper_limit so it doesn't go beyond some max value
            if upper_limit > t_end + max(levels) * delta:
                upper_limit = t_end + max(levels) * delta

            x = x_num(t, upper_limit)
            y = y_num(t, upper_limit)

            x_writer.writerow([t, x])
            y_writer.writerow([t, y])

    print(f"CSV files '{x_filename}' and '{y_filename}' created.")

print("All requested CSV files generated.")